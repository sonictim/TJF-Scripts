

-- Script generated by Lokasenna's GUI Builder


local lib_path = reaper.GetExtState("Lokasenna_GUI", "lib_path_v2")
if not lib_path or lib_path == "" then
    reaper.MB("Couldn't load the Lokasenna_GUI library. Please install 'Lokasenna's GUI library v2 for Lua', available on ReaPack, then run the 'Set Lokasenna_GUI v2 library path.lua' script in your Action List.", "Whoops!", 0)
    return
end
loadfile(lib_path .. "Core.lua")()

----Global Variables
      
      local oldFilenameString = " "        



--function Msg(param) reaper.ShowConsoleMsg(tostring(param).."\n") end --Debug Mesages
--[[
reaper.atexit(function ()     --thank you Solger
  reaper.Undo_BeginBlock()
  reaper.Undo_EndBlock("TJF RENAME at exit", -1)
end)
]]

function take(param) return reaper.GetActiveTake(item[param]) end  --can call take function to match take to item


function titleCase( first, rest )
         return first:upper()..rest:lower()
         --function to call later:  STRING = string.gsub(STRING, "(%a)([%w_']*)", titleCase) 
end

function GetFileExtension(url)
        local str = url
        local temp = ""
        local result = "." -- ! Remove the dot here to ONLY get the extension, eg. jpg without a dot. The dot is added because Download() expects a file type with a dot.
      
        for i = str:len(), 1, -1 do
          if str:sub(i,i) ~= "." then
            temp = temp..str:sub(i,i)
          else
            break
          end
        end
      
        -- Reverse order of full file name
        for j = temp:len(), 1, -1 do
          result = result..temp:sub(j,j)
        end
      
        return result
end



function file_exists(name)
       local f=io.open(name,"r")
       if f~=nil then io.close(f) return true else return false end
end




function itemfilename(item)

    local take = reaper.GetActiveTake(item)
    local source = reaper.GetMediaItemTake_Source(take)
    local parentsource =  reaper.GetMediaSourceParent( source ) -- PCM SOURCE FOR REVERSED ITEMS
    local filename = reaper.GetMediaSourceFileName(source, '')
    if filename == "" then filename = reaper.GetMediaSourceFileName(parentsource, '') end
    return filename
    
end





function filteruniqueitems()  -- THIS WILL FILL AN ARRAY WITH ONLY ITEMS WITH UNIQUE SOURCE
      local unique = {}
      local totalunique = 0
      

      for i=0, reaper.CountSelectedMediaItems(0)-1 do
      
          local currentItem = reaper.GetSelectedMediaItem(0,i)
          local filename = itemfilename(currentItem)
          local path = filename:match('^(.+[\\/])')
          local extension = GetFileExtension(filename)
          
          if not string.find(oldFilenameString, filename) then
          
              oldFilenameString = oldFilenameString .. filename
              totalunique = totalunique + 1
              unique[totalunique] = currentItem

          end--if
      
          
      end--for
      
      return unique
      
end



function OK()
        reaper.Undo_BeginBlock()
        local items = {}

        
        gfx.quit()
        if reaper.GetSelectedMediaItem(0,0) then
        
        
            if GUI.Val("Rename") == 2 then
        
                  items = filteruniqueitems() -- build array of items with unique source
            else for i=1, reaper.CountSelectedMediaItems(0) do items[i] = reaper.GetSelectedMediaItem(0,i-1) end
            end--if
          
            
            local newNames = ProcessInput(items) -- Ask user for input and build new names
            
            if newNames and #items == #newNames then
                
                for i=1, #items do 
                    if GUI.Val("Rename") == 2 then 
                          local check = SafeToRename(items[i], newNames[i])
                          if check == 2 then return
                          elseif check == 7 then
                          elseif check or check == 6 then
                              RenameItemAndSource(items[i], newNames[i]) 
                          end
                    else
                        reaper.GetSetMediaItemTakeInfo_String( reaper.GetActiveTake(items[i]), "P_NAME", newNames[i], true)
                    end
                end--for
            end--if
                
            reaper.Main_OnCommand(40047, 0)--Peaks: Build any missing peaks
            --reaper.Main_OnCommand(41858, 0)--Item: Set item name from active take filename
            reaper.UpdateArrange()
            
        end--if
        

        GUI.quit = true
        
        reaper.Undo_EndBlock("TJF RENAME OK", -1)
        


end--OK


function Cancel()
        reaper.Undo_BeginBlock(0)
        reaper.Undo_EndBlock("TJF RENAME cancel", -1)
        test = reaper.Undo_DoUndo2( 0 )
        gfx.quit()
        GUI.quit = true
        reaper.UpdateTimeline(0)
      
end

function GetTakeNameInfo()
      

      ------------ GET/SET THE VARIABLE DEFAULTS STORED IN THE SESSION
      local project = reaper.GetExtState("TJFRename", "Project")
          if project == "" then 
              project = reaper.GetProjectName(0, 512) 
              project = string.gsub(project, ".RPP", "")
          end
      GUI.Val("SHOW", project)
          

      local designer = reaper.GetExtState("TJFRename", "Designer")
          if designer == "" then designer = "TF" end
      GUI.Val("DSGNR", designer)
      
      
      if reaper.GetSelectedMediaItem(0,0) then
      --if reaper.GetSelectedMediaItem(0,0) then
              
              local retval, name = reaper.GetSetMediaItemTakeInfo_String(reaper.GetActiveTake(reaper.GetSelectedMediaItem(0,0)), "P_NAME", "nothing", false) --get first selected item name
              
              local category = string.match(name, "^.-%_")
              if category == nil then category = reaper.GetExtState("TJFRename", "Category") end
              category = string.gsub(category, "_", "")
              GUI.Val("CATID", category)
    
      
              ------------ CLEAN UP UNDESIREABLE CHARACTERS
              if project ~= "" then name = string.gsub(name, "_" .. project, "") end
              if designer ~= "" then name = string.gsub(name, "_" .. designer, "") end
              if category ~= "" then name = string.gsub(name, category .. "_", "") end
              name = string.gsub(name, "(%l)(%u)", "%1 %2") -- expand title case
              name = string.gsub(name, "(%s%u)(%u)", "%1 %2") -- fix single letter words
              name = string.gsub(name, "-Glued", "")
              name = string.gsub(name, "-glued", "")
              name = string.gsub(name, ".wav", "")
              name = string.gsub(name, ".flac", "")
              name = string.gsub(name, ",", " ")
              name = string.gsub(name, "_", " ")
              name = string.gsub(name, "-", " ")
              name = string.gsub(name, "%s+", " ") -- removes excess spaces
        
            
              local number = string.match(name, "%d+")
              number = tostring(number)
              if number == "nil" then number = "" end
              
              name = string.gsub(name, "%d", "") --remove numbers
              GUI.Val("DESC", name )
              GUI.Val("NUMB", number)
     end
     



end


function ProcessInput(items)
      newTakeName = {}
      name = GUI.Val("DESC")
      category = GUI.Val("CATID")
      designer = GUI.Val("DSGNR")
      project = GUI.Val("SHOW")
      number = GUI.Val("NUMB")
      
      
      
      
      -------FORMAT INPUT VARIABLES FOR FINAL ITEM NAME
      designer = designer:upper()
      project = project:upper()
      
      if project ~= "" then name = string.gsub(name, "_" .. project, "") end
      if designer ~= "" then name = string.gsub(name, "_" .. designer, "") end
      if category ~= "" then name = string.gsub(name, category .. "_", "") end
    
      name = string.gsub(name, "(%a)([%w_']*)", titleCase) -- title case the name string
      name = string.gsub(name, " ", "") -- remove spaces
      name = string.gsub(name, "_", "") 
      name = string.gsub(name, "'", "")

      if number then number = tonumber(number) end

      if #items > 1 and number == nil then number = 1 end
      if #items > 1 and number < 0 then number = 1 end

      
      -------  BUILD AND ATTACH THE FINAL ITEM NAME FOR EACH ITEM IN THE ARRAY
      for i = 1, #items do
      

          newTakeName[i] = category
          if category ~= "" then newTakeName[i] = newTakeName[i] .. "_" end
          newTakeName[i] = newTakeName[i] .. name
          if number ~= nil then newTakeName[i] = newTakeName[i] .. string.format("%02d", number) end
          if designer ~= "" then newTakeName[i] = newTakeName[i] .. "_" .. designer end
          if project ~= "" then newTakeName[i] = newTakeName[i] .. "_" .. project end
          
          if number then number = number + 1 end
          
          
       end--for
       
       
       --------- STORE VALUES IN SESSION FOR LATER
       reaper.SetExtState("TJFRename", "Project", project, true )
       reaper.SetExtState("TJFRename", "Designer", designer, true )
       reaper.SetExtState("TJFRename", "Category", category, true  )


      return newTakeName


end


function RenameItemAndSource(item, newname)  -- param 1 is item, parameter 2 is new name

          local take = reaper.GetActiveTake(item)
          local name =  reaper.GetTakeName( take )
          --local retval, section, start, length, fade, reverse = reaper.BR_GetMediaSourceProperties( take )

          local source = reaper.GetMediaItemTake_Source(take)
          local parentsource =  reaper.GetMediaSourceParent( source ) -- PCM SOURCE FOR REVERSED ITEMS
          local filename = reaper.GetMediaSourceFileName(source, '')
          if filename == "" then filename = reaper.GetMediaSourceFileName(parentsource, '') end
          
          if filename then
          
                local path = filename:match('^(.+[\\/])')
                local extension = GetFileExtension(filename)
                local newFilename = path .. newname .. extension 
                
                
                os.rename(filename, newFilename)  -- WILL DESTRUCTIVELY RENAME CAREFUL
                
                for i=0, reaper.CountTracks(0)-1 do
                    local track = reaper.GetTrack(0,i)
                
                    local _, chunk = reaper.GetTrackStateChunk(track, "", true )
                    
                    chunk = string.gsub(chunk, filename, newFilename)
                    chunk = string.gsub(chunk, name, newname)
                    
                    reaper.SetTrackStateChunk( track, chunk, true )
                
                end--for

          
          end--if
          
          reaper.Main_OnCommand(40047, 0)--Peaks: Build any missing peaks 
          

end--function

function SafeToRename(item, newTakeName)

        local filename = itemfilename(item)
        local path = filename:match('^(.+[\\/])')
        local extension = GetFileExtension(filename)
        
        filename = path .. newTakeName .. extension
        
        
        if file_exists(filename) then
        
            if not string.find(oldFilenameString, filename) then
            
            
            local replace = reaper.MB(filename .. "\nALREADY EXISTS!!!\nDESTRUCTIVELY REPLACE?","WARNING!!!", 3)
            
            return replace
            end
        
        end--if

   
    return true



end--CheckSafeToRename()

function Main()
    --reaper.Undo_BeginBlock()
    
    
    if startflag ~= 1 then
          GUI.elms.CATID.focus = true
          
          startflag = 1
    end
    
    --CATID.caret = CATID:getcaret()
    --Msg(caret)
   
  
  

  local currentItem = reaper.GetSelectedMediaItem(0,0)

  if    currentItem ~= oldItem
  then
        GetTakeNameInfo()   
  else
        if currentItem then
        
            local items = {}
        
        
            for i=1, reaper.CountSelectedMediaItems(0) do items[i] = reaper.GetSelectedMediaItem(0,i-1) end

            local newNames = ProcessInput(items) -- Ask user for input and build new names
            
            if newNames and #items == #newNames then
                
                for i=1, #items
                do 
                        reaper.GetSetMediaItemTakeInfo_String( reaper.GetActiveTake(items[i]), "P_NAME", newNames[i], true)
                end--for
                
            end--if
                
            reaper.Main_OnCommand(40047, 0)--Peaks: Build any missing peaks
            --reaper.Main_OnCommand(41858, 0)--Item: Set item name from active take filename
            reaper.UpdateArrange()
      
        end--if
  
  end -- if
  
  
  

  oldItem = currentItem
     
  



  --reaper.Undo_EndBlock("TJF Rename Main", -1)
end--Main()





GUI.req("Classes/Class - Options.lua")()
GUI.req("Classes/Class - Button.lua")()
GUI.req("Classes/Class - Textbox.lua")()
-- If any of the requested libraries weren't found, abort the script.
if missing_lib then return 0 end



GUI.name = "Simple UCS Rename"
GUI.x, GUI.y, GUI.w, GUI.h = 0, 0, 640, 192
GUI.anchor, GUI.corner = "mouse", "C"



GUI.New("NUMB", "Textbox", {
    z = 11,
    x = 144,
    y = 144,
    w = 350,
    h = 20,
    caption = "Starting Number (if any) : ",
    cap_pos = "left",
    font_a = 3,
    font_b = "monospace",
    color = "txt",
    bg = "wnd_bg",
    shadow = true,
    pad = 4,
    undo_limit = 20
})

GUI.New("SHOW", "Textbox", {
    z = 11,
    x = 144,
    y = 112,
    w = 350,
    h = 20,
    caption = "Show / Library : ",
    cap_pos = "left",
    font_a = 3,
    font_b = "monospace",
    color = "txt",
    bg = "wnd_bg",
    shadow = true,
    pad = 4,
    undo_limit = 20
})

GUI.New("CANCEL", "Button", {
    z = 11,
    x = 528,
    y = 128,
    w = 100,
    h = 24,
    caption = "CANCEL",
    font = 2,
    col_txt = "txt",
    col_fill = "elm_frame",
    func = Cancel
})

GUI.New("OK", "Button", {
    z = 11,
    x = 528,
    y = 96,
    w = 100,
    h = 24,
    caption = "OK",
    font = 2,
    col_txt = "txt",
    col_fill = "elm_frame",
    func = OK
})

GUI.New("CATID", "Textbox", {
    z = 11,
    x = 144,
    y = 16,
    w = 350,
    h = 20,
    caption = "Category (CAT ID) : ",
    cap_pos = "left",
    font_a = 3,
    font_b = "monospace",
    color = "txt",
    bg = "wnd_bg",
    shadow = true,
    pad = 4,
    undo_limit = 20
})

GUI.New("Rename", "Radio", {
    z = 11,
    x = 512,
    y = 16,
    w = 120,
    h = 70,
    caption = "Rename",
    optarray = {"Items Only", "Source Media"},
    dir = "v",
    font_a = 2,
    font_b = 3,
    col_txt = "txt",
    col_fill = "elm_fill",
    bg = "wnd_bg",
    frame = true,
    shadow = true,
    swap = nil,
    opt_size = 20
})

GUI.New("DSGNR", "Textbox", {
    z = 11,
    x = 144,
    y = 80,
    w = 350,
    h = 20,
    caption = "Designer / Vendor : ",
    cap_pos = "left",
    font_a = 3,
    font_b = "monospace",
    color = "txt",
    bg = "wnd_bg",
    shadow = true,
    pad = 4,
    undo_limit = 20
})

GUI.New("DESC", "Textbox", {
    z = 11,
    x = 144,
    y = 48,
    w = 350,
    h = 20,
    caption = "Description (FX Name) : ",
    cap_pos = "left",
    font_a = 3,
    font_b = "monospace",
    color = "txt",
    bg = "wnd_bg",
    shadow = true,
    pad = 4,
    undo_limit = 20
})




GUI.func = Main
GUI.freq = 0

GUI.Init()
GUI.Main()



